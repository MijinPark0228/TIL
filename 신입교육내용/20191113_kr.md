2019.11.13(水) - 신입 개발자 10분 교육

back-end처리에서 느려지는 이유 중 4개와 그에 따른 대책

### １．로직이 최적화 되어 있지 않음.

- 무의미한 공백

- 사용하지 않은 플러그인, 메소드가 남아 있음. 

- 루프 처리가 많음, 또는 루프 처리 안에서 배열, 오브젝트를 만들고 있음. 

- 중복 처리가 많음. 

- 정의되어 있지 않은 로컬, 글로벌 변수.
  (php의 경우 이론적으로 값이 정의되어 있지 있는 변수보다 9배 느림. )

### ２．처리 속도가 비교적으로 느린 메소드를 사용. 

ex）

array_push($array, "orange") → $array[]="orange";

array_search('orange', $array), is_null($array) → isset($array[“orange”])

intval($str) → (int)$str

if($bool === false) → if(!$bool)  

* php 의 코드 규칙에서 안되는 경우가 있지만 변수명, 변수값이 확실하게 boolea이고, 변수명이 boolean형인 것을 알수 있다면 사용해도 된다.
  `if(!$result)` 는  `$result=0`, `$result=false` 와 같은 경우  if판정이 `true`가 되어버린다.
  `$result`에 맞게 적절하게 사용해야한다.
  따라서 `$isItem` 과 같은 변수명과 정확하게 boolean형인 경우에 사용되어야 한다. 

### ３．SQL이 최적화 되어 있지 않음. 

- SELECT 

`SELECT * ` 를 사용하지 않고 필요한 컬럼 (데이터), 만을 취득하도록 한다. 

cgi서버와 DB 서버가 나누어져서 구성되는 경우가 일반적이기 때문에 네트워크를 통해 검색 결과를 반환한다. 네트워크를 통해 받기 때문에 양이 많으면 네트워크 영역을 점유 해버리기 때문에 속도 저하가 발생 할수도 있다. 
또 , select * 의 경우 DB에서 디스크에 있는 내용을 전부 가져오는데, 실제로는 index데이터 (키값 등) 만 필요한 경우가 있다. index키값은 메모리에 있기 때문에 select id 의 경우 select * 로 id만 가져오는 것보다 당연하게 훨씬 더 빠르다.
・explain을 공부해서 최적화 된 SQL문을 만들자! 
・DB구조에 대해서 공부를 하자! 

* INDEX를 사용하지 않음  
   → ★**EXPLAIN**（실행계획）= 쿼리 퍼포먼스를 확인한다. 
* INSERT・UPDATE 
   → 필요한 경우에 select분으로 변경하여 EXPLAIN을 확인한다. 또는 대량의 데이터를 업데이트 테스트하여 적절한 SQL을 찾는다
* DB에는 꼭 필요한 데이터만 넣도록 설계를 잘 할 것. 

### ４．서버 버전 이나 cgi언어 버전이 낮다. 

### 5．스토리지 디스크(저장소) 속도

  	  : 최근에는 SSD를 주로 사용하기 때문에 큰 문제는 없지만, 그래도 고려가 필요.

### 6. 액세스 부하

：액세스가 집중 되면 서버처리가 늘어서 늦어짐. 

### 7. 네트워크 구조가 불필요한 경유가 많음. 

서버가 늘어나면 복잡해 지는데, DB, Application, cache, Search Engine 등 다양한 복수의 서버가 필요하게 됨에 따라서 네트워크 설계가 잘못하면 네트워크 혼잡이라는 현상이 발생한다. 