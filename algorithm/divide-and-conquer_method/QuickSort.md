## Quick Sort (**クイックソート**)

#### 説明

- 특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 

  각 부분배열에 대해서 퀵정렬을 순환적으로 적용하는 방식

- 피벗이 제자리를 잡도록하여 정렬하는 방식

  피벗(pivot) : 두 부분배열로 분할할 때 기준이 되는 특정 원소


* 피벗을 30이라고 했을 때 아래의 표처럼 분할이 된다.

| 분할전 :  | <u>***30***</u> (피벗) | 45        | 50   | 20   | 10   | 1                 | 40   | 25   |           |      |
| --------- | ---------------------- | --------- | ---- | ---- | ---- | ----------------- | ---- | ---- | --------- | ---- |
|           |                        |           |      |      |      |                   |      |      |           |      |
|           | （                   | 부분배열1 |      | ）   |      | <u>***피벗***</u> |      | （   | 부분배열2 | ）   |
| 분할 후 : | 1                      | 10        | 20   | 25   |      | <u>***30***</u>   |      | 40   | 45        | 50   |



왼쪽 부분배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값



분할 : 피벗을 기준으로 주어진 두 부분배열로 분할.

정복 : 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여, 각 부분배열을 정렬.

결합 : 필요없음.



#### 性能

1.   최악의 경우

* 아래와  같이 극심한 불균형적 분할에서는 성능이 좋지 않다.

  * 피벗만 제자리를 잡고,나머지 모든 원소가 하나의 부분배열이 되는 경우
  * 피벗이 항상 부분배열의 최솟값 또는 최댓값이 되는 경우
  * 입력 데이터가 정렬된 경우 AND 피벗을 배열의 처음 원소로 지정한 경우

  `T(n)=T(n-1)+T(0)+Θ(n)(n>0),T(0)=0 `

  `T(n)=T(n-1)+Θ(n)`

  ` T(n)=O(n2)`

2. 최선의 경우

* 항상 동일한 크기의 두 부분배열로 분할 되는 경우

  `T(n)=T(ën/2û)+T(ën/2û)+Θ(n)(n>1) T(1)=1`

  `T(n)=2T(n/2)+Θ(n)`

  `T(n)=O(nlogn)`
  
  
  ## Quick Sort (**クイックソート**)
  
  #### 説明
  
  - 특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 
  
    각 부분배열에 대해서 퀵정렬을 순환적으로 적용하는 방식
  
  - 피벗이 제자리를 잡도록하여 정렬하는 방식
  
    피벗(pivot) : 두 부분배열로 분할할 때 기준이 되는 특정 원소
  
  
  * 피벗을 30이라고 했을 때 아래의 표처럼 분할이 된다.
  
  | 분할전 :  | <u>***30***</u> (피벗) | 45        | 50   | 20   | 10   | 1                 | 40   | 25   |           |      |
  | --------- | ---------------------- | --------- | ---- | ---- | ---- | ----------------- | ---- | ---- | --------- | ---- |
  |           |                        |           |      |      |      |                   |      |      |           |      |
  |           | （                   | 부분배열1 |      | ）   |      | <u>***피벗***</u> |      | （   | 부분배열2 | ）   |
  | 분할 후 : | 1                      | 10        | 20   | 25   |      | <u>***30***</u>   |      | 40   | 45        | 50   |
  
  
  
  왼쪽 부분배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값
  
  
  
  분할 : 피벗을 기준으로 주어진 두 부분배열로 분할.
  
  정복 : 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여, 각 부분배열을 정렬.
  
  결합 : 필요없음.
  
  
  
  #### 性能
  
  1.   최악의 경우
  
  * 아래와  같이 극심한 불균형적 분할에서는 성능이 좋지 않다.
  
    * 피벗만 제자리를 잡고,나머지 모든 원소가 하나의 부분배열이 되는 경우
    * 피벗이 항상 부분배열의 최솟값 또는 최댓값이 되는 경우
    * 입력 데이터가 정렬된 경우 AND 피벗을 배열의 처음 원소로 지정한 경우
  
    `T(n)=T(n-1)+T(0)+Θ(n)(n>0),T(0)=0 `
  
    `T(n)=T(n-1)+Θ(n)`
  
    ` T(n)=O(n2)`
  
  2. 최선의 경우
  
  * 항상 동일한 크기의 두 부분배열로 분할 되는 경우
  
    `T(n)=T(ën/2û)+T(ën/2û)+Θ(n)(n>1) T(1)=1`
  
    `T(n)=2T(n/2)+Θ(n)`
  
    `T(n)=O(nlogn)`